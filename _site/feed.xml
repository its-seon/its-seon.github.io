<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="kr"><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="kr" /><updated>2024-04-27T23:00:23+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">its-seon</title><subtitle>Hi i&apos;m student and i&apos;m studying ROBOTICS</subtitle><author><name>Juno Seon</name></author><entry><title type="html">rrt algorithm (c++)</title><link href="http://localhost:4000/2024/04/27/rrt-algorithm.html" rel="alternate" type="text/html" title="rrt algorithm (c++)" /><published>2024-04-27T00:00:00+09:00</published><updated>2024-04-27T00:00:00+09:00</updated><id>http://localhost:4000/2024/04/27/rrt-algorithm</id><content type="html" xml:base="http://localhost:4000/2024/04/27/rrt-algorithm.html"><![CDATA[<h1>RRT Algorithm</h1>

<p>RRT(Rapidly-exploring Random Tree) 알고리즘은 수많은 경로계획(Path Planning) 알고리즘 중 하나로 샘플링 기반의 경로계획 알고리즘이다.</p>

<p>RRT는 풀네임에서 알 수 있듯이 Tree 자료구조를 사용하며 시작지점을 root로 하는 Tree라고 생각하면 된다.</p>

<p>Random Point를 생성하여 시작지점(Start Point)에서 목표지점(Destination Point)까지 Tree를 확장하여 도달하는 알고리즘이라고 할 수 있다.</p>

<p>아래는 RRT 알고리즘의 단계를 쉽게 이해되도록 설명한 것이다. (쉽게 설명하고자 노력하였음…)</p>

<ol>
  <li>새로운 Random Point를 생성한다.</li>
  <li>생성된 Random Point는 Tree에서 가장 가까운 노드를 찾고, jump 길이만큼 New Point를 생성한다. (jump는 사람이 정하는 parameter, jump가 길수록 목적지에 빠르게 도착할 수 있음)</li>
  <li>New Point는 2번 과정에서 찾은 Tree에서 가장 가까운 노드를 부모노드(Parent Node)로 갖고, 기존의 Tree로 편입된다.</li>
  <li>New Point가 장애물 안에 위치한다면 경로로 인정될 수 없으니 New Point를 Tree에서 제거한다.</li>
  <li>New Point와 부모노드를 이은 경로(Branch)가 장애물과 겹친다면 경로로 인정될 수 없으니 New Point를 Tree에서 제거한다.</li>
  <li>1~5번 과정을 도착지점에 도달할 때까지 반복한다.</li>
</ol>

<hr />
<p>조금 더 쉽게 이해할 수 있도록 그림으로 보자.</p>

<p>먼저 이렇게 생긴 맵이 있다고 가정하자. 빨간색은 시작지점, 파란색은 도착지점, 보라색은 장애물이다. 오른쪽은 트리구조를 나타낸 것이다.
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/4a1e8271-e089-452a-a9dd-cb8db1bf6ddd" alt="rrt1" /></p>

<p>Random Point를 생성한다.
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/940a14aa-0151-4516-af86-398754145ca3" alt="rrt2" /></p>

<p>1번과 가장 가까운 노드를 찾고 jump 길이만큼 떨어진 곳에 1번 New Point를 생성한다. 1번은 start와 가장 가깝기 때문에 start를 부모노드로 갖는다.
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/31e5e218-f378-4701-adb7-236535abaad4" alt="rrt3" /></p>

<p>1번 New Point는 장애물과 겹치지 않기 때문에 트리에 편입시킨다.
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/d2398edf-373f-46e3-a4eb-ab057d4e9fa4" alt="rrt4" /></p>

<p>(이제부터는 jump길이만큼 Random Point가 생성된다고 가정한다. 즉 Random Point를 New Point라고 생각하자.)</p>

<p>마찬가지로 2번 New Point를 생성하고 2번과 가장 가까운 노드인 1번노드를 부모노드로 갖도록 트리에 편입시킨다.
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/91c5924c-89c3-4c05-a42c-4c0c4d83706e" alt="rrt5" /></p>

<p>그러나 2번 New Point는 장애물과 겹쳐 경로가 될 수 없기 때문에 트리에서 제거한다.
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/9eceeac4-064a-4f34-a8c2-f2a1450e7a86" alt="rrt6" /></p>

<p>3번 New Point를 생성한다. 3번 New Point와 가장 가까운 노드를 트리에서 찾으면 start가 가장 가깝기 때문에 start를 부모노드로 갖도록 편입시킨다. (장애물과 겹치지 않음)
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/f0980efc-94ab-456a-8dcf-206bcc1b94eb" alt="rrt7" /></p>

<p>4번 New Point를 생성한다. 4번과 가장 가까운 노드를 트리에서 찾을 때 3번이 가장 가깝기 때문에 3번을 부모노드로 갖도록 편입시킨다. (장애물과 겹치지 않음)
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/63c6c506-36b1-472b-8d7d-a9562b24142e" alt="rrt8" /></p>

<p>이런식으로 반복하다보면 장애물과 겹치는 Point들은 트리에 추가될 수 없으며 언젠가는 목적지에 도달하는 경로가 생성될 수 있다.
<img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/40f2a400-3e0e-4aed-9718-f35183da6225" alt="rrt9" /></p>

<hr />
<h3>단점</h3>

<p>RRT 알고리즘은 아주 유명한 경로계획법이지만, 여러가지 단점도 존재한다.</p>
<ul>
<li>샘플링 개수가 충분하지 않다면 경로를 찾지 못할 수 있다. (모든 샘플링 기반 경로계획법의 단점)</li>
<li>경로를 찾더라도 최적(optimal) 경로가 아니다.</li>
<li>도착점까지 수렴하는데 많은 시간이 소요되며, 예측이 불가능하다.</li>
<li>산출된 경로가 랜덤 샘플링의 성격상 완만하지 않아 실제 로봇이 그대로 주행하기는 어려울 수 있다. (갑자기 90도로 꺽는 곳에서는 자동차는 주행할 수 없음)</li>
</ul>

<hr />
<h3>요약</h3>

<p>RRT 알고리즘은 유명한 랜덤 샘플링 경로계획법으로 실제 로봇 소프트웨어에서 많이 사용되는 알고리즘이다. 기존의 RRT 알고리즘의 단점을 보완하기 위해 RRT*와 같은 알고리즘도 나왔으며 계속적으로 연구가 되는 것을 알 수 있다.</p>

<hr />
<h3>Reference</h3>

<p><a href="https://pasus.tistory.com/74">https://pasus.tistory.com/74</a></p>

<hr />
<h3>c++ 구현</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">"opencv2/opencv.hpp"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">parentIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Obstacle</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">leftTop</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">rightBottom</span><span class="p">;</span>
    <span class="n">Obstacle</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">lt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">rb</span><span class="p">)</span> <span class="o">:</span> <span class="n">leftTop</span><span class="p">(</span><span class="n">lt</span><span class="p">),</span> <span class="n">rightBottom</span><span class="p">(</span><span class="n">rb</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">jump</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Obstacle</span><span class="o">&gt;</span> <span class="n">obstacles</span><span class="p">;</span>

<span class="n">Point</span> <span class="n">newPoint</span><span class="p">;</span>

<span class="cm">/* start and destionation setup */</span>
<span class="n">Point</span> <span class="n">start</span><span class="p">;</span>
<span class="n">Point</span> <span class="n">destination</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">initRRT</span><span class="p">(</span><span class="kt">int</span> <span class="n">startX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startY</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endY</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">startX</span><span class="p">,</span> <span class="n">startY</span><span class="p">);</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">endX</span><span class="p">,</span> <span class="n">endY</span><span class="p">);</span>

    <span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* create obstacles */</span>
<span class="kt">void</span> <span class="n">initObstacles</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">obstacles</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">obstacles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Obstacle</span><span class="p">({</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">},</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">}));</span>
    <span class="n">obstacles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Obstacle</span><span class="p">({</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">},</span> <span class="p">{</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">}));</span>
    <span class="n">obstacles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Obstacle</span><span class="p">({</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">},</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">}));</span>
<span class="p">}</span>

<span class="cm">/* generate random point */</span>
<span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">mt19937</span> <span class="n">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="n">uniform_int_distribution</span><span class="o">&lt;&gt;</span> <span class="n">dis_x</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
<span class="n">uniform_int_distribution</span><span class="o">&lt;&gt;</span> <span class="n">dis_y</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>

<span class="n">Point</span> <span class="n">generateRandomPoint</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">dis_x</span><span class="p">(</span><span class="n">gen</span><span class="p">),</span> <span class="n">dis_y</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* find the nearest point */</span>
<span class="n">Point</span><span class="o">&amp;</span> <span class="n">nearestPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">randomPoint</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">nearestIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">randomPoint</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">randomPoint</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">minDistance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
            <span class="n">nearestIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">path</span><span class="p">[</span><span class="n">nearestIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* check if the random point is within the obstacles */</span>
<span class="kt">bool</span> <span class="n">isInObstacle</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">obs</span> <span class="o">:</span> <span class="n">obstacles</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span>
            <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check if the path intersects with the obstacles */</span>
<span class="kt">bool</span> <span class="n">checkPathIntersectionWithObstacles</span><span class="p">(</span><span class="n">Point</span><span class="o">&amp;</span> <span class="n">nearest</span><span class="p">,</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">newPoint</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">obs</span> <span class="o">:</span> <span class="n">obstacles</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="n">topRight</span> <span class="o">=</span> <span class="p">{</span><span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">.</span><span class="n">y</span><span class="p">};</span>
        <span class="n">Point</span> <span class="n">bottomLeft</span> <span class="o">=</span> <span class="p">{</span><span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">.</span><span class="n">y</span><span class="p">};</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span> <span class="n">Point</span><span class="o">&gt;&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{</span><span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">,</span> <span class="n">topRight</span><span class="p">},</span>
            <span class="p">{</span><span class="n">topRight</span><span class="p">,</span> <span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">},</span>
            <span class="p">{</span><span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">,</span> <span class="n">bottomLeft</span><span class="p">},</span>
            <span class="p">{</span><span class="n">bottomLeft</span><span class="p">,</span> <span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">}</span>
        <span class="p">};</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">o1</span> <span class="o">=</span> <span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
            <span class="kt">double</span> <span class="n">o2</span> <span class="o">=</span> <span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
            <span class="kt">double</span> <span class="n">o3</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">nearest</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">nearest</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
            <span class="kt">double</span> <span class="n">o4</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">o1</span> <span class="o">*</span> <span class="n">o2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">o3</span> <span class="o">*</span> <span class="n">o4</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* generate path */</span>
<span class="kt">void</span> <span class="n">generatePath</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">randomPoint</span> <span class="o">=</span> <span class="n">generateRandomPoint</span><span class="p">();</span>
    <span class="n">Point</span><span class="o">&amp;</span> <span class="n">nearest</span> <span class="o">=</span> <span class="n">nearestPoint</span><span class="p">(</span><span class="n">randomPoint</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">atan2</span><span class="p">(</span><span class="n">randomPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">randomPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">nearest</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="n">newPoint</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">nearest</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">jump</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">nearest</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">jump</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"New point: ("</span> <span class="o">&lt;&lt;</span> <span class="n">newPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">newPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInObstacle</span><span class="p">(</span><span class="n">newPoint</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkPathIntersectionWithObstacles</span><span class="p">(</span><span class="n">nearest</span><span class="p">,</span> <span class="n">newPoint</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">newPoint</span><span class="p">.</span><span class="n">parentIndex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nearest</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newPoint</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">x</span> <span class="o">-</span> <span class="n">destination</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">y</span> <span class="o">-</span> <span class="n">destination</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">jump</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destination reached."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">updateVisualization</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">img</span><span class="p">.</span><span class="n">setTo</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">obs</span> <span class="o">:</span> <span class="n">obstacles</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">rectangle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obs</span><span class="p">.</span><span class="n">leftTop</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obs</span><span class="p">.</span><span class="n">rightBottom</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Draw lines from each point to its parent</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">parentIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cv</span><span class="o">::</span><span class="n">line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">parentIndex</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">parentIndex</span><span class="p">].</span><span class="n">y</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">cv</span><span class="o">::</span><span class="n">line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="n">cv</span><span class="o">::</span><span class="n">circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">start</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">FILLED</span><span class="p">);</span> <span class="c1">// Green for start</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">destination</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">destination</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">FILLED</span><span class="p">);</span> <span class="c1">// Blue for destination</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">newPoint</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">165</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">FILLED</span><span class="p">);</span>  <span class="c1">// Orange for newPoint</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"RRT Path Planning"</span><span class="p">,</span> <span class="n">img</span><span class="p">);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// Short delay to update the display</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">initRRT</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">770</span><span class="p">,</span> <span class="mi">770</span><span class="p">);</span> <span class="c1">// startX, startY, endX, endY point</span>
    <span class="n">initObstacles</span><span class="p">();</span> <span class="c1">// Initialize obstacles</span>

    <span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxIterations</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span> <span class="c1">// Limit the number of iterations to avoid infinite loop</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iterations</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">maxIterations</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Max iterations reached."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">generatePath</span><span class="p">();</span>
        <span class="n">updateVisualization</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">x</span> <span class="o">-</span> <span class="n">destination</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">y</span> <span class="o">-</span> <span class="n">destination</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">jump</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Wait for a key press</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Path generated with "</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" points."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<h3>실행결과</h3>

<p><img src="https://github.com/its-seon/its-seon.github.io/assets/145862553/1365e7d5-3f89-41d3-b43b-95c315af72c2" alt="Screenshot from 2024-04-27 22-50-31" /></p>]]></content><author><name>Juno Seon</name></author><category term="path_planning" /><summary type="html"><![CDATA[RRT Algorithm]]></summary></entry></feed>